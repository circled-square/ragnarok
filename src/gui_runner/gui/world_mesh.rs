use std::cmp::max;
use std::collections::{HashMap, HashSet};
use std::ops::{Range, RangeFrom};
use glium::{Display, VertexBuffer};
use nalgebra_glm::{UVec2, Vec3, vec3};
use rand::prelude::SmallRng;
use rand::{Rng, SeedableRng};
use robotics_lib::world::tile::{Content, Tile, TileType};
use crate::gui_runner::PartialWorld;
use num_traits::Float;

#[derive(Clone, Copy, Debug)]
pub(crate) struct Vertex {
    pub position: [f32; 3],
    pub color: [f32; 3],
}
impl Vertex {
    pub fn null() -> Self {
        Self { position: [f32::infinity(); 3], color: [1.0; 3] }
    }
    pub fn is_null(&self) -> bool { self.position[0].is_infinite() }
}
implement_vertex!(Vertex, position, color);


pub(crate) struct WorldMesh {
    pub vbo: VertexBuffer<Vertex>,
    vertices: Vec<Vertex>,
    world_size: usize,

    content_meshes_indices_map: HashMap<(u32, u32), (usize, Content)>,
    empty_content_meshes: Vec<usize>, // content meshes tagged for replacement
}
impl WorldMesh {
    const TRIS_PER_TILE : usize = 8;
    const VERTICES_PER_TILE : usize = Self::TRIS_PER_TILE * 3;

    const TRIS_IN_ROBOT_MESH : usize = 8;
    const VERTICES_IN_ROBOT_MESH : usize = Self::TRIS_IN_ROBOT_MESH * 3;

    const TRIS_IN_CONTENT_MESH : usize = 16;
    const VERTICES_IN_CONTENT_MESH : usize = Self::TRIS_IN_CONTENT_MESH * 3;

    #[allow(unused)]
    fn robot_mesh(&self) -> Range<usize> { 0..Self::VERTICES_IN_ROBOT_MESH }
    #[allow(unused)]
    fn tiles_mesh(&self) -> Range<usize> { Self::VERTICES_IN_ROBOT_MESH..Self::VERTICES_IN_ROBOT_MESH+Self::VERTICES_PER_TILE*self.world_size*self.world_size }
    fn content_meshes(&self) -> RangeFrom<usize> { Self::VERTICES_IN_ROBOT_MESH+Self::VERTICES_PER_TILE*self.world_size*self.world_size.. }
    fn content_meshes_slice(&self) -> &[Vertex] {
        let content_meshes_range = self.content_meshes();
        &self.vertices[content_meshes_range]
    }
    fn content_meshes_slice_mut(&mut self) -> &mut [Vertex] {
        let content_meshes_range = self.content_meshes();
        &mut self.vertices[content_meshes_range]
    }
    fn null_content_mesh() -> [Vertex; Self::VERTICES_IN_CONTENT_MESH] { [Vertex::null(); Self::VERTICES_IN_CONTENT_MESH] }

    fn min_number_of_empty_content_meshes(world_size: usize) -> usize {
        world_size.next_power_of_two() / 4
    }

    fn increase_content_meshes_size(&mut self) {
        //number of null content meshes to add to the storage
        let content_meshes_len = self.content_meshes_slice().len();
        let reallocation_size_difference = max(8, content_meshes_len / Self::VERTICES_IN_CONTENT_MESH / 2);
        let content_meshes_start = self.content_meshes().start;
        let content_meshes_end = content_meshes_start + content_meshes_len;
        assert_eq!(content_meshes_end, self.vertices.len());

        self.empty_content_meshes.reserve(reallocation_size_difference);
        self.vertices.reserve_exact(reallocation_size_difference * Self::VERTICES_IN_CONTENT_MESH);
        for _ in 0..reallocation_size_difference {
            self.empty_content_meshes.push(self.vertices.len());
            self.vertices.extend_from_slice(&Self::null_content_mesh());
        }

        assert_eq!(self.vertices.len(), content_meshes_end + reallocation_size_difference * Self::VERTICES_IN_CONTENT_MESH);
    }
    fn get_empty_content_mesh_or_realloc(&mut self) -> usize {
        let mut was_none_case = false;
        let ret = match self.empty_content_meshes.pop() {
            Some(empty_content_mesh) => empty_content_mesh,
            None => {
                self.increase_content_meshes_size();
                was_none_case = true;
                self.empty_content_meshes.pop().unwrap()
            }
        };

        for (i,v) in self.vertices[ret..ret + Self::VERTICES_IN_CONTENT_MESH].iter().enumerate() {
            assert!(v.is_null(), "{v:?} was_none_case? {was_none_case} i = {i}");
        }

        ret
    }
    fn insert_content_mesh(&mut self, tile_pos: UVec2, elevation: usize, content: Content) {
        assert_ne!(content, Content::None);

        let prev_content = self.content_meshes_indices_map.get_mut(&(tile_pos.x, tile_pos.y)).cloned();
        let (content_mesh_index, do_write_vertices) = match prev_content {
            None => (self.get_empty_content_mesh_or_realloc(), true),
            Some((index, content_in_hashmap)) => (index, content_in_hashmap.index() != content.index()),
        };


        if do_write_vertices {
            if let Some(content_mesh) = Self::content_to_mesh(&content, tile_pos, elevation) {
                self.vertices[content_mesh_index..content_mesh_index + Self::VERTICES_IN_CONTENT_MESH].copy_from_slice(&content_mesh);
            }

            self.content_meshes_indices_map.insert((tile_pos.x, tile_pos.y), (content_mesh_index, content.clone()));
        }
    }

    fn fill_factor_is_low(&self) -> bool {
        let content_meshes_total_space = self.content_meshes_slice().len()/Self::VERTICES_IN_CONTENT_MESH;

        content_meshes_total_space > Self::min_number_of_empty_content_meshes(self.world_size)
        && self.empty_content_meshes.len() > content_meshes_total_space / 2
    }
    fn remove_content_mesh(&mut self, tile_pos: UVec2) {
        let prev_content = self.content_meshes_indices_map.remove(&(tile_pos.x, tile_pos.y));
        if let Some((index, _prev_content)) = prev_content {
            //hashmap reports content where there is none
            self.empty_content_meshes.push(index);
            self.vertices[index..index+Self::VERTICES_IN_CONTENT_MESH].copy_from_slice(&Self::null_content_mesh());
            if self.fill_factor_is_low() {
                let mut new_content_meshes_indices_map = HashMap::new();
                let mut new_content_meshes = Vec::new();
                let mut new_empty_content_meshes = Vec::new();
                let content_meshes_start = self.content_meshes().start;

                for (coords, (old_index, content)) in self.content_meshes_indices_map.drain() {
                    let new_index = new_content_meshes.len();
                    new_content_meshes[new_index..new_index+Self::VERTICES_IN_CONTENT_MESH].copy_from_slice(&self.vertices[old_index..old_index+Self::VERTICES_IN_CONTENT_MESH]);
                    new_content_meshes_indices_map.insert(coords, (new_index + content_meshes_start, content));
                }

                let new_content_meshes_size = self.content_meshes_slice().len() * 2 / 3;

                for i in new_content_meshes.len()..new_content_meshes_size {
                    new_empty_content_meshes.push(i + content_meshes_start);
                }

                self.content_meshes_indices_map = new_content_meshes_indices_map;
                self.content_meshes_slice_mut().copy_from_slice(&new_content_meshes);
                self.empty_content_meshes = new_empty_content_meshes;

            }
        }
        //do nothing if the hashmap agrees there is no content
    }
    fn update_vbo(&mut self, display: &Display) {
        if self.vbo.len() == self.vertices.len() {
            self.vbo.write(&self.vertices);
        } else {
            self.vbo = VertexBuffer::dynamic(display, &self.vertices).unwrap();
        }
    }

    pub fn new(display: &Display, world_size: usize) -> Self {

        let number_of_empty_content_meshes_at_start = Self::min_number_of_empty_content_meshes(world_size);

        let start_of_content_meshes = Self::VERTICES_IN_ROBOT_MESH + world_size * world_size * Self::VERTICES_PER_TILE;
        let number_of_vertices = start_of_content_meshes + number_of_empty_content_meshes_at_start * Self::VERTICES_IN_CONTENT_MESH;
        let vertices = vec![Vertex::null(); number_of_vertices];

        let vbo = VertexBuffer::<Vertex>::empty_dynamic(display, number_of_vertices).unwrap();

        let content_meshes_indices_map = HashMap::new();
        let empty_content_meshes = Vec::from_iter(
            (0..number_of_empty_content_meshes_at_start)
            .map(|i| start_of_content_meshes + i * Self::VERTICES_IN_CONTENT_MESH)
        );

        Self { vertices, vbo, world_size, content_meshes_indices_map, empty_content_meshes }
    }
    pub fn update(&mut self, world: &mut PartialWorld, tiles_to_refresh: &HashSet<UVec2>, display: &Display) {
        assert_eq!(self.world_size, world.world.len());
        let color_displace_amount = 0.1;
        let position_displace_amount = 0.1;

        //update robot mesh
        {
            let robot_position = (world.robot_position.x as usize * 2, world.robot_position.y as usize * 2);

            let robot_vertices_repetitionless = [
                [ 0.0, 0.0,  0.0],
                [ 0.5, 1.0,  0.0],
                [ 0.0, 1.0,  0.5],
                [-0.5, 1.0,  0.0],
                [ 0.0, 1.0, -0.5],
                [ 0.0, 2.0,  0.0],
            ];
            let robot_tris = [
                [0, 1, 2],
                [0, 2, 3],
                [0, 3, 4],
                [0, 4, 1],
                [5, 1, 2],
                [5, 2, 3],
                [5, 3, 4],
                [5, 4, 1],
            ].map(|tri| tri.map(|i| robot_vertices_repetitionless[i]));

            let mut robot_color_rng = SmallRng::seed_from_u64(1);

            let robot_vertices = robot_tris.map(|tri| {
                let color = rand_displace_vec(vec3(0.2, 0.2, 0.2), 0.07, &mut robot_color_rng);
                tri.map(|[x,y,z]| {
                    Vertex {
                        position: [
                            world.robot_position.x as f32 + x + 0.5,
                            get_elevation(robot_position, &world.world).unwrap() + y + 0.5,
                            world.robot_position.y as f32 + z + 0.5
                        ],
                        color: *color.as_ref()
                    }
                })
            }).into_iter().flatten().collect::<Vec<_>>();

            self.vertices[0..Self::VERTICES_IN_ROBOT_MESH].copy_from_slice(&robot_vertices);
        }

        for tile_pos in tiles_to_refresh.iter().cloned() {
            if let Some(tile) = &world.world[tile_pos.x as usize][tile_pos.y as usize] {
                //tile vertices
                {
                    let mut tile_vertices = vec![];
                    tile_vertices.reserve(24);
                    let mut positions = vec![];
                    positions.reserve(24);
                    let color = tile_to_color(tile);
                    let mut rng = SmallRng::seed_from_u64(tile_pos.x as u64 + ((tile_pos.y as u64) << 32));
                    let bool_distr = rand::distributions::Uniform::<i8>::new(0, 2);

                    for n in 0..9 {
                        positions.push([tile_pos.x * 2 + n % 3, tile_pos.y * 2 + n / 3]);
                    }

                    for quad in 0..4 {
                        let quad_offset = [0, 1, 3, 4][quad];
                        let quad_positions_index =
                            //randomize how the quads are split into tris
                            if rng.sample(bool_distr) == 0 { [0usize, 1, 3, 4] } else { [1, 4, 0, 3] }
                                // then offset the indices in the mesh to get the correct positions for the current quad
                                .map(|n| n + quad_offset);
                        let quad_positions = quad_positions_index.map(|i| positions[i]);

                        for tri in [&quad_positions[0..3], &[quad_positions[2], quad_positions[1], quad_positions[3]]] {
                            let color = rand_displace_vec(color, color_displace_amount, &mut rng).as_ref().clone();
                            for [x, z] in tri {
                                let mut position = [*x as f32 / 2.0, get_elevation((*x as usize, *z as usize), &world.world).unwrap(), *z as f32 / 2.0];
                                if *x % 2 != 1 || *z % 2 != 1 {
                                    let mut vtx_pos_rng = SmallRng::seed_from_u64(*x as u64 + ((*z as u64) << 32));
                                    position = rand_displace_vec(Vec3::from(position), position_displace_amount, &mut vtx_pos_rng).as_ref().clone();
                                }
                                tile_vertices.push(Vertex { position, color });
                            }
                        }
                    }

                    let vertex_position = Self::VERTICES_IN_ROBOT_MESH + (tile_pos.y as usize * self.world_size + tile_pos.x as usize) * Self::VERTICES_PER_TILE;
                    self.vertices[vertex_position..vertex_position + Self::VERTICES_PER_TILE].copy_from_slice(&tile_vertices);
                }
                // content vertices
                {
                    if tile.content == Content::None {
                        self.remove_content_mesh(tile_pos);
                    } else {
                        self.insert_content_mesh(tile_pos, tile.elevation, tile.content.clone());
                    }
                }

            }
        }

        self.update_vbo(&display);
    }

    fn content_to_mesh(c: &Content, tile_pos: UVec2, elevation: usize) -> Option<[Vertex; Self::VERTICES_IN_CONTENT_MESH]> {
        /*
        to get the vertices from blender use the following code; this will create a file ~/file.txt with our meshes inside.

import bpy

save_to_file = 'file.txt'

def _get_vertex_colors(blender_mesh):
    mesh = blender_mesh.data
    colors = {}
    try:
        color_layer = mesh.vertex_colors[0]
    except:
        return colors
    mesh_loops = {li: loop.vertex_index for li, loop in enumerate(mesh.loops)}
    vtx_colors = {mesh_loops[li]: data.color for li, data in color_layer.data.items()}
    for idx, color in vtx_colors.items():
        colors[idx] = [color[0], color[1], color[2]]
    return [color for idx, color in colors.items()]

with open(save_to_file, 'w') as file:
    for obj in bpy.context.collection.objects:
        vertices = [(vert.co.x, vert.co.y, vert.co.z) for vert in obj.data.vertices]
        vertex_colors = _get_vertex_colors(obj)
        tris = [[vert for vert in polygon.vertices] for polygon in obj.data.polygons]
        file.write('Content::' + obj.name + '(_) => Some((' + str(vertices) + '.as_slice(), ' + str(vertex_colors) + '.as_slice(), ' + str(tris) + '.as_slice())),\n')
    file.close()

        */
        let content_mesh = match c {
            Content::Rock(_) => Some(([(0.3378884494304657, -0.03197399526834488, -0.3138851821422577), (-0.017235703766345978, -0.031974006444215775, 0.5290529131889343), (-0.5396137237548828, 0.36432549357414246, -0.3138851821422577), (-0.3971201777458191, -0.4913543462753296, -0.3138851821422577)].as_slice(), [[0.45490196347236633, 0.45490196347236633, 0.45490196347236633], [0.45490196347236633, 0.45490196347236633, 0.45490196347236633], [0.45490196347236633, 0.45490196347236633, 0.45490196347236633], [0.45490196347236633, 0.45490196347236633, 0.45490196347236633]].as_slice(), [[0, 1, 3], [3, 1, 2], [2, 0, 3], [2, 1, 0]].as_slice())),
            Content::Tree(_) => Some(([(0.31201931834220886, -0.10876885801553726, -0.30857741832733154), (-0.038514453917741776, 0.05763806402683258, 3.1042990684509277), (-0.15606489777565002, 0.30776160955429077, -0.30857741832733154), (-0.27112331986427307, -0.20002827048301697, -0.308577299118042), (0.6444399356842041, -0.21872302889823914, 1.4419856071472168), (-0.038617659360170364, 0.10554106533527374, 4.437355995178223), (-0.26767897605895996, 0.5929371118545532, 1.4419856071472168), (-0.4918842017650604, -0.39655300974845886, 1.4419856071472168)].as_slice(), [[0.3176470696926117, 0.0, 0.0117647061124444], [0.3176470696926117, 0.0, 0.0117647061124444], [0.3176470696926117, 0.0, 0.0117647061124444], [0.3176470696926117, 0.0, 0.0117647061124444], [0.13725490868091583, 0.48235294222831726, 0.16470588743686676], [0.13725490868091583, 0.48235294222831726, 0.16470588743686676], [0.13725490868091583, 0.48235294222831726, 0.16470588743686676], [0.13725490868091583, 0.48235294222831726, 0.16470588743686676]].as_slice(), [[0, 1, 3], [3, 1, 2], [2, 0, 3], [2, 1, 0], [4, 5, 7], [7, 5, 6], [6, 4, 7], [6, 5, 4]].as_slice())),
            Content::Fire => Some(([(-0.32559970021247864, -0.26937350630760193, 1.3679674863815308), (-0.16653382778167725, 0.22312411665916443, -0.6427121162414551), (-0.4869377613067627, -0.22495314478874207, -0.6427121162414551), (0.14466208219528198, -0.49166497588157654, -0.6427121162414551), (0.23177923262119293, -0.15800246596336365, 1.7272160053253174), (-0.08245214819908142, -0.025336697697639465, -0.6427121162414551), (-0.0577271431684494, 0.14848700165748596, 1.663439154624939), (-0.4386885166168213, 0.04237576574087143, -0.6427121162414551), (-0.07724404335021973, -0.2942878305912018, -0.6427121162414551), (-0.11699183285236359, 0.24955877661705017, 1.213547706604004), (-0.4523026943206787, 0.49277862906455994, -0.6427121162414551), (-0.2662193775177002, -0.05372508615255356, -0.6427121162414551), (0.21032358705997467, 0.19283175468444824, 1.3051484823226929), (0.2994685769081116, 0.4499984085559845, -0.6490964293479919), (-0.11341477930545807, 0.0641375407576561, -0.6490964293479919), (0.0003167837858200073, -0.1539779156446457, -0.6490964293479919), (0.011084333062171936, 0.08784336596727371, 1.7208317518234253), (-0.17736846208572388, 0.48467180132865906, -0.6490964293479919), (0.2779310345649719, -0.3365449607372284, -0.6490964293479919), (0.28869858384132385, -0.09472362697124481, 0.814437210559845), (0.10024579614400864, 0.30210480093955994, -0.6490964293479919), (0.4765293300151825, -0.041005998849868774, -0.6490964293479919), (0.3594602048397064, 0.17086261510849, 1.1580370664596558), (0.145167738199234, 0.41092434525489807, -0.6490964293479919), (0.43441757559776306, -0.2411147952079773, 0.644436776638031), (0.09909849613904953, -0.34424054622650146, -0.6490964293479919), (0.4849032759666443, -0.49133914709091187, -0.6490964293479919), (0.4580884277820587, -0.1400468647480011, -0.6490964293479919), (0.36667829751968384, -0.28513243794441223, 1.5278772115707397), (0.2810766398906708, -0.4793027937412262, -0.6490964293479919), (0.20032186806201935, -0.20994777977466583, -0.6490964293479919), (-0.005427256226539612, -0.3374654948711395, 1.2538800239562988), (-0.2022072672843933, -0.48339056968688965, -0.6490964293479919), (-0.24333104491233826, -0.33492985367774963, 0.7266889810562134), (-0.48546910285949707, -0.12873470783233643, -0.6490964293479919), (-0.07642987370491028, -0.48767566680908203, -0.6490964293479919)].as_slice(), [[0.9254902005195618, 0.0, 0.1764705926179886], [0.9254902005195618, 0.0, 0.1764705926179886], [0.9254902005195618, 0.0, 0.1764705926179886], [0.9254902005195618, 0.0, 0.1764705926179886], [0.9254902005195618, 0.0, 0.1764705926179886], [0.9254902005195618, 0.0, 0.1764705926179886], [0.9254902005195618, 0.0, 0.1764705926179886], [0.9254902005195618, 0.0, 0.1764705926179886], [0.9254902005195618, 0.0, 0.1764705926179886], [0.9254902005195618, 0.0, 0.1764705926179886], [0.9254902005195618, 0.0, 0.1764705926179886], [0.9254902005195618, 0.0, 0.1764705926179886], [0.9254902005195618, 0.0, 0.1764705926179886], [0.9254902005195618, 0.0, 0.1764705926179886], [0.9254902005195618, 0.0, 0.1764705926179886], [0.9254902005195618, 0.0, 0.1764705926179886], [0.9254902005195618, 0.0, 0.1764705926179886], [0.9254902005195618, 0.0, 0.1764705926179886], [0.9254902005195618, 0.0, 0.1764705926179886], [0.9254902005195618, 0.0, 0.1764705926179886], [0.9254902005195618, 0.0, 0.1764705926179886], [0.9254902005195618, 0.0, 0.1764705926179886], [0.9254902005195618, 0.0, 0.1764705926179886], [0.9254902005195618, 0.0, 0.1764705926179886], [0.9254902005195618, 0.0, 0.1764705926179886], [0.9254902005195618, 0.0, 0.1764705926179886], [0.9254902005195618, 0.0, 0.1764705926179886], [0.9254902005195618, 0.0, 0.1764705926179886], [0.9254902005195618, 0.0, 0.1764705926179886], [0.9254902005195618, 0.0, 0.1764705926179886], [0.9254902005195618, 0.0, 0.1764705926179886], [0.9254902005195618, 0.0, 0.1764705926179886], [0.9254902005195618, 0.0, 0.1764705926179886], [0.9254902005195618, 0.0, 0.1764705926179886], [0.9254902005195618, 0.0, 0.1764705926179886], [0.9254902005195618, 0.0, 0.1764705926179886]].as_slice(), [[2, 0, 1], [3, 4, 5], [8, 6, 7], [11, 9, 10], [14, 12, 13], [15, 16, 17], [18, 19, 20], [21, 22, 23], [26, 24, 25], [27, 28, 29], [30, 31, 32], [35, 33, 34]].as_slice())),
            Content::Coin(_) => Some(([(-6.208817349140361e-10, 0.25122952461242676, 0.012981771491467953), (-0.2377641350030899, 0.07848376780748367, 0.012981771491467953), (-0.14694631099700928, -0.20102474093437195, 0.012981771491467953), (0.14694631099700928, -0.20102474093437195, 0.012981771491467953), (0.2377641350030899, 0.07848376780748367, 0.012981771491467953), (-6.208817349140361e-10, 0.25122952461242676, 0.038945313543081284), (-0.2377641350030899, 0.07848376780748367, 0.038945313543081284), (-0.14694631099700928, -0.20102474093437195, 0.038945313543081284), (0.14694631099700928, -0.20102474093437195, 0.038945313543081284), (0.2377641350030899, 0.07848376780748367, 0.038945313543081284)].as_slice(), [[1.0, 0.843137264251709, 0.08235294371843338], [1.0, 0.843137264251709, 0.0], [1.0, 0.843137264251709, 0.0], [1.0, 0.843137264251709, 0.007843137718737125], [1.0, 0.843137264251709, 0.03529411926865578], [1.0, 0.843137264251709, 0.0235294122248888], [1.0, 0.843137264251709, 0.0], [1.0, 0.843137264251709, 0.0], [1.0, 0.843137264251709, 0.0], [1.0, 0.843137264251709, 0.0]].as_slice(), [[4, 2, 1], [6, 8, 9], [0, 9, 4], [3, 7, 2], [1, 5, 0], [4, 8, 3], [2, 6, 1], [1, 0, 4], [4, 3, 2], [9, 5, 6], [6, 7, 8], [0, 5, 9], [3, 8, 7], [1, 6, 5], [4, 9, 8], [2, 7, 6]].as_slice())),
            Content::Bin(_) => Some(([(8.75, 0.25, -0.11763688921928406), (9.25, 0.25, 0.6470893621444702), (9.25, 0.25, -0.11763688921928406), (8.75, -0.25, -0.11763688921928406), (8.75, -0.25, 0.6470893621444702), (8.75, -0.25, 0.0874662846326828), (8.75, 0.25, 0.0874662846326828), (9.25, -0.25, 0.0874662846326828), (9.25, 0.25, 0.0874662846326828), (8.75, 0.25, 0.6470893621444702), (9.25, -0.25, -0.11763688921928406), (9.25, -0.25, 0.6470893621444702)].as_slice(), [[0.4470588266849518, 0.4470588266849518, 0.4470588266849518], [0.4470588266849518, 0.4470588266849518, 0.4470588266849518], [0.4470588266849518, 0.4470588266849518, 0.4470588266849518], [0.4470588266849518, 0.4470588266849518, 0.4470588266849518], [0.4470588266849518, 0.4470588266849518, 0.4470588266849518], [0.4470588266849518, 0.4470588266849518, 0.4470588266849518], [0.4470588266849518, 0.4470588266849518, 0.4470588266849518], [0.4470588266849518, 0.4470588266849518, 0.4470588266849518], [0.42352941632270813, 0.42352941632270813, 0.42352941632270813], [0.42352941632270813, 0.42352941632270813, 0.42352941632270813], [0.42352941632270813, 0.42352941632270813, 0.42352941632270813], [0.42352941632270813, 0.42352941632270813, 0.42352941632270813]].as_slice(), [[4, 0, 3], [11, 3, 10], [9, 2, 0], [1, 10, 2], [7, 6, 5], [4, 9, 0], [11, 4, 3], [9, 1, 2], [1, 11, 10], [7, 8, 6]].as_slice())),
            Content::Garbage(_) => Some(([(-0.4120151996612549, 0.0023247026838362217, 0.4016544222831726), (-0.660269558429718, 0.0023247464559972286, -0.476776123046875), (0.13029776513576508, 0.6880912184715271, -0.49337661266326904), (0.4024461507797241, -0.6636604070663452, -0.4921177625656128)].as_slice(), [[0.15294118225574493, 0.15294118225574493, 0.15294118225574493], [0.15294118225574493, 0.15294118225574493, 0.15294118225574493], [0.1568627506494522, 0.1568627506494522, 0.1568627506494522], [0.15294118225574493, 0.15294118225574493, 0.15294118225574493]].as_slice(), [[0, 1, 3], [3, 1, 2], [2, 0, 3], [2, 1, 0]].as_slice())),
            Content::Crate(_) => Some(([(-0.25, -0.25, -0.04999998211860657), (-0.25, -0.25, 0.44999998807907104), (-0.25, 0.25, -0.04999998211860657), (-0.25, 0.25, 0.44999998807907104), (0.25, -0.25, -0.04999998211860657), (0.25, -0.25, 0.44999998807907104), (0.25, 0.25, -0.04999998211860657), (0.25, 0.25, 0.44999998807907104)].as_slice(), [[0.3176470696926117, 0.15294118225574493, 0.0], [0.3176470696926117, 0.15294118225574493, 0.0], [0.3137255012989044, 0.14901961386203766, 0.0], [0.3137255012989044, 0.14901961386203766, 0.0], [0.3137255012989044, 0.14901961386203766, 0.0], [0.3176470696926117, 0.15294118225574493, 0.003921568859368563], [0.3137255012989044, 0.14901961386203766, 0.0], [0.3333333432674408, 0.16078431904315948, 0.007843137718737125]].as_slice(), [[1, 2, 0], [3, 6, 2], [7, 4, 6], [5, 0, 4], [6, 0, 2], [3, 5, 7], [1, 3, 2], [3, 7, 6], [7, 5, 4], [5, 1, 0], [6, 4, 0], [3, 1, 5]].as_slice())),
            Content::Bank(_) => Some(([(-0.4099918603897095, -0.4099918603897095, -0.08643713593482971), (-0.4099918603897095, -0.4099918603897095, 0.699999988079071), (-0.4099918603897095, 0.4099918603897095, -0.08643713593482971), (-0.4099918603897095, 0.4099918603897095, 0.699999988079071), (0.4099918603897095, -0.4099918603897095, -0.08643713593482971), (0.4099918603897095, -0.4099918603897095, 0.699999988079071), (0.4099918603897095, 0.4099918603897095, -0.08643713593482971), (0.4099918603897095, 0.4099918603897095, 0.699999988079071), (-0.09475528448820114, 0.24353207647800446, 0.7047137022018433), (-0.09475528448820114, -0.05648123100399971, 0.7047137022018433), (0.13201972842216492, 0.09176065027713776, 0.7047137022018433), (-0.04922379553318024, 0.03316980227828026, 0.7102861404418945), (-0.04922379553318024, 0.15317513048648834, 0.7102861404418945), (-0.09475528448820114, 0.057657741010189056, 0.7047137022018433), (0.04148619994521141, 0.0924665629863739, 0.7102861404418945), (-0.09475528448820114, -0.2423555701971054, 0.7047137022018433), (0.13201972842216492, -0.09411369264125824, 0.7047137022018433), (0.04148619994521141, -0.0934077799320221, 0.7102861404418945), (-0.04922379553318024, -0.15270453691482544, 0.7102861404418945), (-0.04922379553318024, -0.03269920498132706, 0.7102861404418945)].as_slice(), [[0.38823530077934265, 0.3843137323856354, 0.3843137323856354], [0.3803921639919281, 0.3686274588108063, 0.364705890417099], [0.3843137323856354, 0.3803921639919281, 0.3803921639919281], [0.3843137323856354, 0.3803921639919281, 0.3803921639919281], [0.3843137323856354, 0.3803921639919281, 0.3803921639919281], [0.3843137323856354, 0.3803921639919281, 0.3803921639919281], [0.3843137323856354, 0.3803921639919281, 0.3803921639919281], [0.3843137323856354, 0.3803921639919281, 0.3803921639919281], [0.3843137323856354, 0.3803921639919281, 0.3803921639919281], [0.3843137323856354, 0.3803921639919281, 0.3803921639919281], [0.3843137323856354, 0.3803921639919281, 0.3803921639919281], [1.0, 0.843137264251709, 0.0], [1.0, 0.843137264251709, 0.0], [1.0, 0.843137264251709, 0.0], [0.3843137323856354, 0.3803921639919281, 0.3803921639919281], [0.3843137323856354, 0.3803921639919281, 0.3803921639919281], [0.3843137323856354, 0.3803921639919281, 0.3803921639919281], [1.0, 0.843137264251709, 0.0], [1.0, 0.843137264251709, 0.0], [1.0, 0.843137264251709, 0.0]].as_slice(), [[1, 2, 0], [3, 6, 2], [7, 4, 6], [5, 0, 4], [12, 11, 14], [3, 5, 7], [1, 3, 2], [3, 7, 6], [7, 5, 4], [5, 1, 0], [8, 9, 10], [3, 1, 5], [19, 18, 17], [13, 15, 16]].as_slice())),
            Content::Market(_) => Some(([(-0.4099918603897095, -0.4099918603897095, -0.08643713593482971), (-0.4099999964237213, -0.4099999964237213, 0.699999988079071), (-0.4099918603897095, 0.4099918603897095, -0.08643713593482971), (-0.4099999964237213, 0.4099999964237213, 0.699999988079071), (0.4099918603897095, -0.4099918603897095, -0.08643713593482971), (0.4099999964237213, -0.4099999964237213, 0.699999988079071), (0.4099918603897095, 0.4099918603897095, -0.08643713593482971), (0.4099999964237213, 0.4099999964237213, 0.699999988079071), (-0.13967810571193695, 0.21798956394195557, 0.7049999237060547), (0.13967810571193695, -0.21798944473266602, 0.7049999237060547), (0.13967810571193695, 0.21798932552337646, 0.7049999237060547), (0.0, 0.029551558196544647, 0.7099999785423279), (-0.07042834162712097, 0.2638569176197052, 0.7099999785423279), (0.07042834162712097, 0.2638569176197052, 0.7099999785423279), (-0.13967810571193695, -0.2179895043373108, 0.7049999237060547), (0.0, -0.1586645543575287, 0.7100000381469727), (-0.08091257512569427, -0.25283193588256836, 0.7100000381469727), (-0.07951050251722336, 0.07901877164840698, 0.7099999785423279), (0.07951045036315918, -0.25283193588256836, 0.7099999785423279), (0.07951045036315918, 0.07901877909898758, 0.7099999785423279)].as_slice(), [[0.38823530077934265, 0.3843137323856354, 0.3843137323856354], [0.3803921639919281, 0.3686274588108063, 0.364705890417099], [0.3843137323856354, 0.3803921639919281, 0.3803921639919281], [0.3843137323856354, 0.3803921639919281, 0.3803921639919281], [0.3843137323856354, 0.3803921639919281, 0.3803921639919281], [0.3843137323856354, 0.3803921639919281, 0.3803921639919281], [0.3843137323856354, 0.3803921639919281, 0.3803921639919281], [0.3843137323856354, 0.3803921639919281, 0.3803921639919281], [0.3843137323856354, 0.3803921639919281, 0.3803921639919281], [0.3843137323856354, 0.3803921639919281, 0.3803921639919281], [0.3843137323856354, 0.3803921639919281, 0.3803921639919281], [1.0, 0.843137264251709, 0.0], [1.0, 0.843137264251709, 0.0], [1.0, 0.843137264251709, 0.0], [0.3843137323856354, 0.3803921639919281, 0.3803921639919281], [0.3843137323856354, 0.3803921639919281, 0.3803921639919281], [0.3843137323856354, 0.3803921639919281, 0.3803921639919281], [1.0, 0.843137264251709, 0.0], [0.3843137323856354, 0.3803921639919281, 0.3803921639919281], [0.3843137323856354, 0.3803921639919281, 0.3803921639919281]].as_slice(), [[1, 2, 0], [3, 6, 2], [7, 4, 6], [5, 0, 4], [12, 11, 13], [3, 5, 7], [1, 3, 2], [3, 7, 6], [7, 5, 4], [5, 1, 0], [8, 9, 10], [3, 1, 5], [17, 16, 15], [8, 14, 9], [19, 18, 15], [15, 18, 16]].as_slice())),
            Content::Building => Some(([(-0.4099918603897095, -0.4099918603897095, -0.08643713593482971), (-0.4099999964237213, -0.4099999964237213, 0.699999988079071), (-0.4099918603897095, 0.4099918603897095, -0.08643713593482971), (-0.4099999964237213, 0.4099999964237213, 0.699999988079071), (0.4099918603897095, -0.4099918603897095, -0.08643713593482971), (0.4099999964237213, -0.4099999964237213, 0.699999988079071), (0.4099918603897095, 0.4099918603897095, -0.08643713593482971), (0.4099999964237213, 0.4099999964237213, 0.699999988079071)].as_slice(), [[0.38823530077934265, 0.3843137323856354, 0.3843137323856354], [0.3803921639919281, 0.3686274588108063, 0.364705890417099], [0.3843137323856354, 0.3803921639919281, 0.3803921639919281], [0.3843137323856354, 0.3803921639919281, 0.3803921639919281], [0.3843137323856354, 0.3803921639919281, 0.3803921639919281], [0.3843137323856354, 0.3803921639919281, 0.3803921639919281], [0.3843137323856354, 0.3803921639919281, 0.3803921639919281], [0.3843137323856354, 0.3803921639919281, 0.3803921639919281]].as_slice(), [[1, 2, 0], [3, 6, 2], [7, 4, 6], [5, 0, 4], [3, 5, 7], [1, 3, 2], [3, 7, 6], [7, 5, 4], [5, 1, 0], [3, 1, 5]].as_slice())),
            Content::Bush(_) => Some(([(0.4148986041545868, -0.008101888932287693, -0.26230984926223755), (-0.15059588849544525, -0.048712365329265594, 0.5702793598175049), (-0.4626035988330841, 0.3881976008415222, -0.26230984926223755), (-0.320110023021698, -0.46748223900794983, -0.26230984926223755)].as_slice(), [[0.007843137718737125, 0.4470588266849518, 0.05098039284348488], [0.0, 0.4470588266849518, 0.05098039284348488], [0.03921568766236305, 0.4470588266849518, 0.062745101749897], [0.0, 0.4470588266849518, 0.05098039284348488]].as_slice(), [[0, 1, 3], [3, 1, 2], [2, 0, 3], [2, 1, 0]].as_slice())),
            Content::Fish(_) => Some(([(0.14466208219528198, -0.4916650056838989, -0.04400932788848877), (0.0338396281003952, -0.2569722533226013, 0.07906436920166016), (-0.08245214819908142, -0.025336697697639465, -0.04400932788848877), (-0.35608571767807007, 0.21312670409679413, 0.052388906478881836), (-0.4054293632507324, 0.3558378219604492, -0.04400932788848877), (-0.3115275502204895, 0.08005983382463455, -0.04400932788848877), (-0.0344802662730217, -0.028086066246032715, -0.04434084892272949), (-0.07024367153644562, 0.10367397964000702, 0.07873284816741943), (-0.1351398378610611, 0.3337121307849884, -0.04434084892272949), (0.24415117502212524, -0.2120320200920105, -0.04434084892272949), (0.21207943558692932, -0.08457395434379578, 0.0316624641418457), (0.1433466076850891, 0.15028735995292664, -0.04434084892272949), (0.4765293300151825, -0.041005998849868774, -0.04434084892272949), (0.3396662473678589, 0.15898624062538147, 0.04950606822967529), (0.145167738199234, 0.4109243154525757, -0.04434084892272949), (0.302175372838974, -0.3737998604774475, 0.007847744971513748), (0.16511258482933044, -0.3212507665157318, -0.03684765845537186), (0.4218108654022217, -0.4191240072250366, -0.03684765845537186), (-0.2563358247280121, -0.32569101452827454, 0.02710556983947754), (-0.37291109561920166, -0.22642011940479279, -0.04434084892272949), (-0.17598268389701843, -0.39922913908958435, -0.04434084892272949)].as_slice(), [[0.686274528503418, 0.6274510025978088, 0.6313725709915161], [0.658823549747467, 0.658823549747467, 0.658823549747467], [0.658823549747467, 0.658823549747467, 0.658823549747467], [0.686274528503418, 0.6274510025978088, 0.6313725709915161], [0.658823549747467, 0.658823549747467, 0.658823549747467], [0.658823549747467, 0.658823549747467, 0.658823549747467], [0.658823549747467, 0.658823549747467, 0.658823549747467], [0.658823549747467, 0.658823549747467, 0.658823549747467], [0.6666666865348816, 0.6509804129600525, 0.6509804129600525], [0.658823549747467, 0.658823549747467, 0.658823549747467], [0.658823549747467, 0.658823549747467, 0.658823549747467], [0.6823529601097107, 0.6313725709915161, 0.6352941393852234], [0.6705882549285889, 0.6470588445663452, 0.6470588445663452], [0.658823549747467, 0.658823549747467, 0.658823549747467], [0.6705882549285889, 0.6509804129600525, 0.6509804129600525], [0.658823549747467, 0.658823549747467, 0.658823549747467], [0.658823549747467, 0.658823549747467, 0.658823549747467], [0.6627451181411743, 0.6549019813537598, 0.6549019813537598], [0.6745098233222961, 0.6392157077789307, 0.6431372761726379], [0.658823549747467, 0.658823549747467, 0.658823549747467], [0.6666666865348816, 0.6509804129600525, 0.6509804129600525]].as_slice(), [[0, 1, 2], [5, 3, 4], [6, 7, 8], [9, 10, 11], [12, 13, 14], [17, 15, 16], [20, 18, 19]].as_slice())),
            Content::JollyBlock(_) => Some(([(-0.25, -0.25, -0.04999999701976776), (-0.25, -0.25, 0.44999998807907104), (-0.25, 0.25, -0.04999999701976776), (-0.25, 0.25, 0.44999998807907104), (0.25, -0.25, -0.04999999701976776), (0.25, -0.25, 0.44999998807907104), (0.25, 0.25, -0.04999999701976776), (0.25, 0.25, 0.44999998807907104), (-0.025000005960464478, 0.1839064508676529, 0.45499998331069946), (-0.025000005960464478, -0.05087052285671234, 0.45499998331069946), (0.025000005960464478, 0.1839064508676529, 0.45499998331069946), (0.025000005960464478, -0.05087052285671234, 0.45499998331069946), (-0.025000005960464478, -0.1547078639268875, 0.45499998331069946), (-0.025000005960464478, -0.10470785200595856, 0.45499998331069946), (0.025000005960464478, -0.1547078639268875, 0.45499998331069946), (0.025000005960464478, -0.10470785200595856, 0.45499998331069946)].as_slice(), [[0.658823549747467, 0.0, 0.6352941393852234], [0.658823549747467, 0.0, 0.6352941393852234], [0.658823549747467, 0.007843137718737125, 0.6352941393852234], [0.658823549747467, 0.003921568859368563, 0.6352941393852234], [0.6549019813537598, 0.01568627543747425, 0.6313725709915161], [0.658823549747467, 0.0, 0.6352941393852234], [0.658823549747467, 0.003921568859368563, 0.6352941393852234], [0.658823549747467, 0.0117647061124444, 0.6352941393852234], [0.9137254953384399, 0.8392156958580017, 0.9058823585510254], [1.0, 1.0, 1.0], [0.9960784316062927, 0.9960784316062927, 0.9960784316062927], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [0.8901960849761963, 0.7921568751335144, 0.8823529481887817], [1.0, 1.0, 1.0]].as_slice(), [[1, 2, 0], [3, 6, 2], [7, 4, 6], [5, 0, 4], [6, 0, 2], [3, 5, 7], [1, 3, 2], [3, 7, 6], [7, 5, 4], [5, 1, 0], [6, 4, 0], [3, 1, 5], [11, 8, 10], [15, 12, 14], [11, 9, 8], [15, 13, 12]].as_slice())),
            Content::Scarecrow => Some(([(0.1743094027042389, -0.13636961579322815, -0.71045982837677), (-0.006979605183005333, -0.07481520622968674, 1.336403727531433), (-0.22681492567062378, 0.044787030667066574, -0.71045982837677), (-0.16167815029621124, -0.34636178612709045, -0.71045982837677), (0.081735759973526, 0.02491089701652527, 1.560507893562317), (0.008452866226434708, -0.07585588097572327, 1.1426702737808228), (0.006344068795442581, -0.22144824266433716, 1.0924530029296875), (0.8502382636070251, -0.07481520622968674, 1.2709208726882935), (0.006344068795442581, 0.03810186684131622, 1.049230933189392), (-0.22620485723018646, -0.07481519877910614, 1.5208446979522705), (-0.8367131948471069, -0.07481535524129868, 1.2709228992462158), (0.04202096164226532, -0.21554821729660034, 1.5553925037384033)].as_slice(), [[0.5764706134796143, 0.5098039507865906, 0.11372549086809158], [0.5764706134796143, 0.5098039507865906, 0.11372549086809158], [0.5764706134796143, 0.5098039507865906, 0.11372549086809158], [0.5764706134796143, 0.5098039507865906, 0.11372549086809158], [0.5764706134796143, 0.5098039507865906, 0.11372549086809158], [0.5764706134796143, 0.5098039507865906, 0.11372549086809158], [0.5764706134796143, 0.5098039507865906, 0.11372549086809158], [0.6901960968971252, 0.6196078658103943, 0.23137255012989044], [0.686274528503418, 0.6196078658103943, 0.23137255012989044], [0.6901960968971252, 0.6196078658103943, 0.22745098173618317], [0.5921568870544434, 0.5254902243614197, 0.13333334028720856], [0.686274528503418, 0.615686297416687, 0.23529411852359772]].as_slice(), [[0, 1, 3], [3, 1, 2], [2, 0, 3], [2, 1, 0], [6, 7, 8], [4, 9, 11], [7, 6, 10], [11, 5, 4], [9, 5, 11], [4, 5, 9], [8, 7, 10], [6, 8, 10]].as_slice())),


            Content::Water(_) | Content::None => { None }
        }.map(|(pos, colors, indices)| {
            let mut vertices = [Vertex::null(); Self::VERTICES_IN_CONTENT_MESH];

            let mut rng = SmallRng::seed_from_u64(tile_pos.x as u64 + ((tile_pos.y as u64) << 32));

            for (i, tri_indices) in indices.iter().cloned().enumerate() {
                let color = colors[tri_indices[0]];
                let color = rand_displace_vec(color.into(), 0.1, &mut rng);
                for j in 0..3 {
                    let (x,y,z) = pos[tri_indices[j]];
                    //blender's coordinate space inverts y and z compared to ours
                    let position = [
                        x + tile_pos.x as f32 + 0.5,
                        z + elevation_to_mesh_space_y(elevation as f32),
                        y + tile_pos.y as f32 + 0.5
                    ];
                    vertices[i*3 + j] = Vertex { position, color: [color.x, color.y, color.z] };
                }
            }

            vertices
        });

        content_mesh
    }
}


fn tile_to_color(t: &Tile) -> Vec3 {
    Vec3::from_row_slice(&match t.tile_type {
        TileType::DeepWater => [0.0, 0.0, 0.3],
        TileType::ShallowWater => [0.0, 0.0, 0.5],
        TileType::Sand => [0.6, 0.6, 0.0],
        TileType::Grass => [0.2, 0.5, 0.0],
        TileType::Street => [0.4, 0.4, 0.4],
        TileType::Hill => [0.3, 0.4, 0.0],
        TileType::Mountain => [0.3, 0.3, 0.3],
        TileType::Snow => [0.9, 0.9, 0.9],
        TileType::Lava => [0.9, 0.0, 0.0],
        TileType::Teleport(_) => [0.8, 0.0, 0.9],
        TileType::Wall => [0.5, 0.5, 0.5],
    })
}


fn rand_displace_vec(v: Vec3, amount: f32, rng: &mut impl Rng) -> Vec3 {
    let distr = rand::distributions::Uniform::new(-1.0, 1.0);
    v.map(|n| n + amount * rng.sample(distr))
}
fn get_elevation(mut p: (usize, usize), w: &Vec<Vec<Option<Tile>>>) -> Option<f32> {
    if p.0 == 0 { p.0 += 1; }
    if p.1 == 0 { p.1 += 1; }
    if p.0 == w.len() * 2 { p.0 -= 1; }
    if p.1 == w.len() * 2 { p.1 -= 1; }
    let p = (p.0-1, p.1-1);

    let ret = if p.0 % 2 == 0 && p.1 % 2 == 0 {
        w[p.0 / 2][p.1 / 2].as_ref()?.elevation as f32
    } else if p.0 % 2 == 0 && p.1 % 2 == 1 {
        let e1 = w[p.0 / 2][p.1 / 2].as_ref().and_then(|t| Some(t.elevation));
        let e2 = w[p.0 / 2][p.1 / 2 + 1].as_ref().and_then(|t| Some(t.elevation));

        let e1 = e1.or(e2)?;
        let e2 = e2.or(Some(e1))?;

        (e1 as f32 + e2 as f32) / 2.0
    } else if p.0 % 2 == 1 && p.1 % 2 == 0 {
        let e1 = w[p.0 / 2][p.1 / 2].as_ref().and_then(|t| Some(t.elevation));
        let e2 = w[p.0 / 2 + 1][p.1 / 2].as_ref().and_then(|t| Some(t.elevation));

        let e1 = e1.or(e2)?;
        let e2 = e2.or(Some(e1))?;

        (e1 as f32 + e2 as f32) / 2.0
    } else {
        let e1 = w[p.0 / 2][p.1 / 2].as_ref().and_then(|t| Some(t.elevation));
        let e2 = w[p.0 / 2 + 1][p.1 / 2].as_ref().and_then(|t| Some(t.elevation));
        let e3 = w[p.0 / 2][p.1 / 2 + 1].as_ref().and_then(|t| Some(t.elevation));
        let e4 = w[p.0 / 2 + 1][p.1 / 2 + 1].as_ref().and_then(|t| Some(t.elevation));
        let mut elevation_vec = vec![];

        e1.inspect(|e| elevation_vec.push(*e));
        e2.inspect(|e| elevation_vec.push(*e));
        e3.inspect(|e| elevation_vec.push(*e));
        e4.inspect(|e| elevation_vec.push(*e));

        elevation_vec.iter().sum::<usize>() as f32 / (elevation_vec.len() as f32)
    };

    Some(elevation_to_mesh_space_y(ret))
}
pub fn elevation_to_mesh_space_y(elevation: f32) -> f32 {
    elevation * 0.2
}